% PREAMBLE

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage[T1]{fontenc}

% DOCUMENT
\begin{document}
Obligatorisk oppgave info233, kladd.

\section{Frister, etc.}
Utlevert [dato], frist [data] klokken [klokkeslett]
Etc. Antar det er samme format som forrige gang, med godkjent, ikke godkjent?
Godtar vi parprogrammering?

Leveringsformatet er et Eclipseprosjekt, eksportert til en komprimert fil. (En av: zip, tgz eller tar.gz, rar godtas ikke.) % Vi kan per lov ikke kommunisere i proprietære formater som rar.


\section{Oppgaven}
Den andre obligen omhandler en utvidelse av et spill, kalt Kjips Kylling, som er en forenklet klon av Chip's Challenge\footnote{Se \url{http://en.wikipedia.org/wiki/Chip\%27s_Challenge} for mer om spillet}.
Spillet har allerede en enkel grafikkmotor, og dere skal utvide spillet.
Lyd er ikke en del av obligen, og dere kan ignorere alt som har med lyd å gjøre. % Skal vi nevne dette til å begynne med, eller vente til de spør på gruppene?

Før dere begynner å kode anbefaler vi å lese godt igjennom oppgaven, se hvordan relevante kodebiter fungerer, og tenke gjennom før en begynner å kode.
Husk å bruke tiden godt. Det er nok å gjøre, og mye blir lettere å gjøre hvis dere har en plan først. % Jeg kan ikke si dette mange nok ganger, men jeg tror jeg gjør et forsøk her. ^_^;

\section{Om koden}
\subsection{Introduksjon til kodebasen}
\label{subsec:kodebase-intro}
Koden er grovt sett designet etter en løs tolkning av MVC.
Det vil si at koden grovt sett har en av tre mulige funksjoner.
\begin{itemize}
\item Den kan representere en bit av en modell\footnote{I spillet ligger disse klassene under game.entity, og dens underpakker}, dvs. forskjellige ting i programmet, som monstre, spilleren og slikt.
\item Eller så kan den være en bit av en kontroller\footnote{Dette ligger i game.controller}, dvs. noe som styrer oppførsel i programmet
\item Til slutt kan den også være en del av presentasjonen\footnote{Og dette ligger i game.view} av programmet.
\end{itemize}

Koden som dere får er sortert under forskjellige pakker, som følger:
\begin{description}
\item [game.controller] Inneholder klassen \emph{Game}, som er en kontroller for spillet.
  Her finner du blant annet en game-loop, som kjører kontinuerlig og som er ansvarlig for å gi ut \emph{ticks}.
\item [game.controller.input] Er hvor input til spillet, som tastatur, mus, gamepads, osv. ligger. Koden dere får har kun en enkel tastaturklasse som kan brukes.
\item [game.entity] Har SimplePlayer som representerer en spiller, og TileLevel som representerer et brett. Andre klasser har egne pakker for å holde ting relativt oversiktlig.
\item [game.entity.monster] Inneholder forskjellige monstre. Når dere får den inneholder den AbstractMonster som er et forenklet monster som ikke har tick() metoden sin implementert, og ExampleMonster som er et monster med alt implementert, slik at dere ser hvordan en kan gjøre det.
\item [game.entity.tiles] Forskjellige klasser som representerer fliser, dvs. en del av brettet, samt hjelpeklasser for å gjøre ting enklere.
\item [game.entity.types] De forskjellige typene entiteter. Her er kun kontrakter, og ikke noen implementerende klasser.
\item [game.io] Har klasser som snakker med disk og evt. andre programmer som en SQL-database.
\item [game.util] Har forskjellige hjelpemetoder, som IOStuff for lesing av filer og slikt, Direction for retninger, og Movement for hjelpemetoder til bevegelser.
\item [game.view] Har GameWindow-klassen som er en JFrame som holder på et lerret.
  I tillegg til metoder for popups, kan du også legge til kode om du vil ha mer GUI.
\item [game.view.gfx] Hvor grafikken blir tegnet, dere trenger ikke endre noe her. % Den ene klassen som kan være relevant å se nærmere på er SpriteLoader som er ansvarlig for å laste bildefiler til grafikksystemet.
\item [game.main] Inneholder utelukkende Main, en classe som er inngangspunktet\footnote{entry-point} for programmet. Det er bare denne klassen i koden dere får som har en main-metode.
\end{description}

TODO: Få dette renskrevet og inn ordentlig: \\
En kan også dele koden opp i kode dere skal modifisere, og resten.\\
Skal røre: game.view.GameWindow, game.controller.Game, game.entity.TileLevel \\
Skal lage: game.io.ResourceLoaderSQL, game.entity.monster.{OppNed TilVenstre TilHøyre, VenstreHøyre, Målsøkende, Patrulje}Monster
    
\section{Oppgaven}
% -- Hvor de skal sette inn kode % Er vel dekket i forrige?
Oppgaven dere skal gjøre kan deles inn i to hoveddeler: Databasebruk og Monstre. I tillegg er det noen underting som også skal legges til etterpå.
\subsection{Utvidelse til bruk av SQL}
\label{subsec:sqloppgave}
TODO: Renskriving: \\
ResourceLoaderSQL skal lages. \\
HighScore tabell skal lagres, og når du kommer i mål skal den skrives ut, med spilleren sin plassering vist. \\

\subsection{Monstre}
\label{subsec:monsteroppgave}
Dere skal lage monstre som går snur seg når de treffer veggen, som er målsøkende og følger en patruljerute.

\subsection{Til slutt}
\label{subsec:ekstra}
Alle brett skal ha en makstid, utvid brett med en maksimal tid de må fullføre et brett på. Hvis en spiller ikke er i mål når tiden går ut har han tapt.


-- Introduksjon til oppgaven
-- ResourceLoaderSQL (sql/maps!)
-- Highscores! (SQL)
-- Monstre (Kø! (Prioritetskø?))
SELECT score, name from HighScoreWHERE level = ? ORDER BY DESC LIMIT 10;

\section{terminologi}
\subsection{game-loop}
\label{subsec:game-loop}
En game-loop er en uendelig løkke, og er tradisjonelt delt inn i to:
\begin{description}
\item [oppdatering] Oppdaterer tilstanden til alle objekter i spillet. Blant annet ting som å sjekke om spilleren har dødd, lese ting fra tastaturet, og la datastyrte entiteter som monstre bevege seg.
\item [tegning] tegner grafikken i spillet.
\end{description}
I spillet dere skal utvide er løkken forenklet, ved at tastaturinput og tegning er gjort for dere.
Det er altså kun oppdatering som skjer i løkken, tegning skjer i en annen tråd.

\subsection{tick}
\label{subsec:tick}
Et tick er en sjanse til en skapning til å velge å gjøre en ting.
Dersom du for eksempel får 4 ticks i sekundet kan ikke en AI reagere raskere enn 1/4 sekund.
Bare fordi du får n ticks betyr ikke at en AI må bruke alle. Den kan utmerket godt kun bevege seg 2 ganger i sekundet, for eksempel.
I vårt spill har alle klasser som implementerer Tickable-kontrakten en tick() metode som er void, og lar objekter av den klassen oppdatere seg selv når metoden blir kalt.


\end{document}
