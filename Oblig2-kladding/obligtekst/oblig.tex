% PREAMBLE

\documentclass[norsk]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[norsk]{babel}

% DOCUMENT
\begin{document}
Obligatorisk oppgave info233, kladd.

\section{Frister, etc.}
\label{sec:frister-og-regler}
Utlevert [dato], frist [data] klokken [klokkeslett]
Etc. Antar det er samme format som forrige gang, med godkjent, ikke godkjent?
Godtar vi parprogrammering?

Leveringsformatet er et Eclipseprosjekt, eksportert til en komprimert fil. (En av: zip, tgz eller tar.gz. Rar-filer godtas ikke.) % Vi kan per lov ikke kommunisere i proprietære formater som rar.
Merk at prosjektet dere får utlevert er i UTF-8. Dere bør derfor etter å ha importert det, sjekke filformatet. Det gjør dere ved å høyreklikke på prosjektmappen, velge properties, og passe på at det ser ut som dette:
\begin{figure}[h!]
  \centering
    \includegraphics[width=1\textwidth]{slik-ser-det-ut.png}
\end{figure}



\section{Oppgaven}
\label{sec:oppgaven}
Den andre obligen omhandler en utvidelse av et spill, kalt Kjips Kylling, som er en forenklet klon av Chip's Challenge\footnote{Se \url{http://en.wikipedia.org/wiki/Chip\%27s_Challenge} for mer om spillet}.
Spillet har allerede en enkel grafikkmotor, og dere skal utvide spillet.
Lyd er ikke en del av obligen, og dere kan ignorere alt som har med lyd å gjøre. % Skal vi nevne dette til å begynne med, eller vente til de spør på gruppene?

Før dere begynner å kode anbefaler vi å lese godt igjennom oppgaven, se hvordan relevante kodebiter fungerer, og tenke gjennom før en begynner å kode.
Husk å bruke tiden godt. Det er nok å gjøre, og mye blir lettere å gjøre hvis dere har en plan først. % Jeg kan ikke si dette mange nok ganger, men jeg tror jeg gjør et forsøk her. ^_^;

\section{Spillet}
\label{sec:spillet}
Spillet Kjips Kylling består av flere brett, en spiller og monstre.
Målet med spillet er å klare alle brettene.
For å klare et brett må du komme deg fra begynnelsen på brettet til slutten.
Dersom du går tom for tid, tar ani et monster, eller tråkker på en dødelig rute i spillet dør du.
Når du dør kan du prøve brettet på nytt.
Brettet består av forskjellige ruter. Noen kan gås på, andre ikke. Noen er dødelige, andre ikke.
Brettet har også forskjellige monstre. Disse monstrene beveger seg etter faste mønstre. Monstrene kan ikke dø i denne utgaven.\footnote{I originalen kunne du drepe et monster ved å lure det til å tråkke på en bombe.}
Når du har nådd slutten på et brett begynner neste brett.

\section{Om koden}
\label{sec:om-koden}
\subsection{Introduksjon til kodebasen}
\label{subsec:kodebase-intro}
Koden er lagt opp etter MVC-mønsteret. Det betyr at koden er en av tre ting.
\begin{itemize}
\item Den kan representere en bit av en modell\footnote{I spillet ligger disse klassene under game.entity, og dens underpakker}, dvs. forskjellige ting i programmet, som monstre, spilleren og slikt.
\item Eller så kan den være en bit av en kontroller\footnote{Dette ligger i game.controller}, dvs. noe som styrer oppførsel i programmet
\item Til slutt kan den også være en del av presentasjonen\footnote{Og dette ligger i game.view} av programmet.
\end{itemize}
I tillegg er det IO-pakker som leser fra disk, snakker med andre programmer, etc.
Her ligger ResourceLoader og implementasjoner, som abstraherer innlasting av ressurser.

Koden som dere får er sortert under forskjellige pakker, som følger:
\begin{description}
\item [game.controller] Inneholder klassen \emph{Game}, som er en kontroller for spillet.
  Her finner du blant annet en game-loop, som kjører kontinuerlig og som er ansvarlig for å gi ut \emph{ticks}.
\item [game.controller.input] Er hvor input til spillet, som tastatur, mus, gamepads, osv. ligger. Koden dere får har kun en enkel tastaturklasse som tar hånd om input. Dere trenger ikke røre noe kode her inne.
\item [game.entity] Har SimplePlayer som representerer en spiller, og TileLevel som representerer et brett. Andre klasser har egne pakker for å holde ting relativt oversiktlig.
\item [game.entity.monster] Inneholder forskjellige monstre. Når dere får den inneholder den AbstractMonster som er et forenklet monster som ikke har tick() metoden sin implementert, og ExampleMonster som er et monster med alt implementert, slik at dere ser hvordan en kan gjøre det.
\item [game.entity.tiles] Forskjellige klasser som representerer fliser, dvs. en del av brettet, samt hjelpeklasser for å gjøre ting enklere.
\item [game.entity.types] De forskjellige typene entiteter. Her er kun kontrakter, og ikke noen implementerende klasser.
\item [game.io] Har klasser som snakker med disk og evt. andre programmer som en SQL-database.
\item [game.util] Har forskjellige hjelpemetoder, som Direction for retninger, og Movement for hjelpemetoder til bevegelser.
\item [game.view] Har GameWindow-klassen som er en JFrame som holder på et lerret.
  I tillegg til metoder for popups, kan du også legge til kode om du vil ha mer GUI.
\item [game.view.gfx] Hvor grafikken blir tegnet. Det er også en klasse for å laste bildefiler inn til grafikkmotoren. Dere trenger ikke endre noe her. % Den ene klassen som kan være relevant å se nærmere på er SpriteLoader som er ansvarlig for å laste bildefiler til grafikksystemet.
\item [game.main] Inneholder utelukkende Main, en classe som er inngangspunktet\footnote{entry-point} for programmet. Det er bare denne klassen i koden dere får som har en main-metode.
\end{description}

%TODO: Få dette renskrevet og inn ordentlig: \\
%Dere skal redigere  game.view.GameWindow, game.controller.Game og game.entity.TileLevel. \\
%Skal lage: game.io.ResourceLoaderSQL og flere monstre i pakken game.entity.monster.\\
%Det er TODO annotasjoner i relevante kodebiter.   
\section{Oppgaven}
Oppgaven dere skal gjøre kan deles inn i to hoveddeler: Databasebruk og Monstre. Det er også noen ekstrating dere skal gjøre.

\subsection{Utvidelse til bruk av SQL}
\label{subsec:sqloppgave}
Dere skal bruke databaser i dette spillet, nærmere bestemt Apache Derby, som kjører som en del av programmet deres, så dere slipper å tenke på innlogging og slikt. % Som VPN for å bruke MySQL serverene til UiB.
Bibliotekene dere trenger kommer med prosjektet, og er lagt til under lib/ mappen, og satt opp i prosjektet.

\subsubsection{ResourceLoaderSQL}
\label{subsec:resourceloadersql}
Prosjektet har en kontrakt ResourceLoader som beskriver hvordan en klasse kan holdes ansvarlig for å laste inn ressurser fra disk,
som blir implementert av klassen ResourceLoaderCSV.
ResourceLoaderCSV leser dataene fra 4 spesifikke .csv\footnote{CSV - Comma Separated Values} filer og henter inn data derfra.
Vi vil at dere skal implementere en ny klasse ResourceLoaderSQL som bruker en SQL basert database til å hente ut data fra.
For at dette må til bør dere gjøre følgende
\begin{enumerate}
\item Se igjennom .csv filene. Dere kan åpne dem i teksteditorer som Vim og Emacs, eller regneark som MS Excel eller LibreOffice Calc.
\item Finn ut av hva datatypene er, og hvordan disse kan overføres til SQL.
\item Finn ut av hva relasjonene er, og hvordan disse blir vedlikeholdt.\footnote{For eksempel, se på alias.csv og standard-tiles.csv}
\item Når dere nå har modellert en database, da, og først da bør dere skrive koden.
\item Og når dere har skrevet koden, sjekk at den virker.
\item Så kan dere begynne å legge dataene inn i databasen.
\item Og nå når dataene er i databasen, og dere vet at den virker, da bør dere skrive ResourceLoaderSQL klassen.
\item Nest sist, bytt ut ResourceLoader loader = new ResourceLoaderCSV(); med ResourceLoader loader = new ResourceLoaderSQL();
\item Til slutt, fiks alle feil som kommer.
\end{enumerate}

Det er noen viktige ufravikelige krav til ResourceLoaderSQL:
Når dere starter opp spillet skal alle data som trengs fra databasen lastes inn med en gang. Dere må derfor mellomlagre data slik at dere slipper å laste inn på nytt.
Dere bør absolutt bruke Map\footnote{se \url{http://docs.oracle.com/javase/7/docs/api/java/util/Map.html}} til å holde på disse dataene, og se på hvordan ResourceLoaderCSV gjør det.
%[Kommentar: Bør de hive over brettene og? Eller holder det å hive over det andre?]
Dere trenger ikke å hive brettene over til SQL.

\subsubsection{HighScore}
\label{subsec:highscore}
HighScore tabell skal lagres, og når du kommer i mål skal den skrives ut, med spilleren sin plassering vist.
\begin{figure}[h!]
  \caption{En mulig måte å vise highscore på. (Tatt fra SkiFree)}
  \centering
    \includegraphics[width=0.5\textwidth]{Mulig-HighScore.png}
\end{figure}

Score i denne sammenhengen er ikke mer komplisert enn antall tidels sekunder brukt, jo færre jo bedre.
Dere må altså lage en ny tabell som holder orden på slikt, og spørringer for å hente ut informasjon.

\subsection{Monstre}
\label{subsec:monster}
I prosjektet nå er det kun et monster som går en tilfeldig retning. Dere skal lage flere av de klassiske monstrene.
I tillegg til å designe klasser for monstre skal dere også legge til en måte å lagre monsterinformasjon på i databasen.
Dere må både lage en tabell for monstertypene, og en som binder monstre til brett i en mange-til-mange-tabell. Denne mange-til-mange-tabellen må si hvilket monster det er snakk om, hvor på kartet den skal være og hvilket brett det er snakk om.
Monstrene dere skal lage\footnote{Dere kan godt begynne med monstre, og putte dem inn i TileLevel istedenfor ExampleMonster. Se linje 119 i game.entity.TileLevel}\\

Monstrene dere skal lage er:
\begin{description}
\item [VenstreMonster] Dette monsteret går oppover til det treffer et hinder. Da snur det til venstre, og går den veien istedenfor.
\item [HøyreMonster] Dette monsteret går oppover til det treffer et hinder. Da snur det til høyre og går den veien istedenfor.
\item [OppNedMonster] Går opp til det treffer en hindring. Da går det ned til det treffer en hindring. Og slik fortsetter det.
\item [VenstreHøyreMonster] Går til venstre til det treffer en hindring til det treffer en hindring. Når monsteret treffer en hindring snur det $180\,^{\circ}$ og går den veien istedenfor.
\item [MålsøkendeMonster] Går alltid ett steg nærmere spilleren. Skal ikke planlegge en rute men bare gå den ruten som tar den nærmere spilleren.
\item [PatruljeMonster] Følger en gitt patrulje. En patrulje er en streng med en av fire tegn i. N for nord, W for vest, E for øst og S for sør.\footnote{Siden resten av koden er på engelsk følger vi samme praksis her.} Når den har fulgt alle stegene i patruljen begynner den forfra igjen. En patrulje på ``NNEESSWW'' skal gå rundt i ring, for eksempel.
\end{description}

I tillegg til å lage en måte å representere monstre på i databasen, og å lage kode for dem, må dere utvide prosjektet til å ta hånd om disse monstrene.
Spesifikt må dere utvide TileLevel til å holde på fler monstre, og å holde orden på hvor de er.
I tillegg må dere ticke alle sammen. Når det bare er et monster er rekkefølgen  opplagt, men når det blir flere vil vi at dere skal la dem tickes etter prioritet.
Det vil si, at dersom to monstre har forskjellig prioritet, skal den med høyest prioritet tickes først. Ellers er rekkefølgen uviktig.
En god måte å gjøre dette på er en prioritetskø.

\section{terminologi}
\subsection{Game-loop}
\label{subsec:game-loop}
En game-loop er en uendelig løkke, og er tradisjonelt delt inn i to:
\begin{description}
\item [oppdatering] Oppdaterer tilstanden til alle objekter i spillet. Blant annet ting som å sjekke om spilleren har dødd, lese ting fra tastaturet, og la datastyrte entiteter som monstre bevege seg.
\item [tegning] tegner verdenen spilleren skal se etter opppdatering.
\end{description}
I spillet dere skal utvide er løkken forenklet, ved at tastaturinput og tegning er gjort for dere.
Det er altså kun oppdatering som skjer i løkken, tegning skjer i en annen tråd.

\subsection{Tick}
\label{subsec:tick}
Et tick er en sjanse til en skapning til å velge å gjøre en ting.
Dersom du for eksempel får 4 ticks i sekundet kan ikke en AI reagere raskere enn 1/4 sekund.
Bare fordi du får n ticks betyr ikke at en AI må bruke alle. Den kan utmerket godt kun bevege seg annenhver tick, eller sjeldnere.
I vårt spill har alle klasser som implementerer Tickable-kontrakten en tick() metode som er void, og lar objekter av den klassen oppdatere seg selv når metoden blir kalt.

\subsection{Sprite}
\label{subsec:sprite}
En sprite er et mulig bilde av en entitet eller en del av en entitet i et spill.\footnote{På eldre maskiner som den første Nintendoen, var det sterkte begrensede ressurser. En fant ut at dersom en lastet inn flere bilder på en gang som ett stort bilde var det mye raskere for grafikkprosessoren. En kunne også veldig enkelt be om å kun tegne en bit av bildet. Tradisjonen med å samle bilder fra samme entitet på et sted ble da født. En kunne også modde for eksempel det første GTA spillet med å åpne opp spritesheets og tegne om på ting.}
I Kjips Kylling er for eksempel spilleren som ser ned en sprite. Det er tre andre sprites som brukes om spillerfiguren, nemlig når den ser opp, til venstre eller til høyre.
En gulveflis har bare en sprite, siden den ikke kan snu seg til venstre.
\subsection{Spritesheet}
\label{subsec:spritesheet}
En spritesheet er en bildefil som inneholder mange sprites samlet i en fil. Ble opprinnelig brukt for å spare på systemressurser, og blir fortsatt brukt på internett av den grunn.
(Hvis du har mange bildefiler som må sendes over serveren må du motta og behandle mange kall. Dersom bildefilene er små bruker du plutselig mer tid på å behandle kallene enn på å sende informasjon.
Men dersom du samler alle de små bildene sammen i ett bilde og sender det, og deretter sakser ut biter av bildet til nettsiden din, går alt mye fortere.
Vi som har såpass små bildefiler kunne utmerket godt sluppet unna med å ha separate bildefiler, men vi valgte å ha det med, fordi det er enklere å se hvordan bildene ser ut, mindre File objekter å skyfle rundt på, for å følge tradisjonen, og fordi det er greit å ha sett hvis du i fremtiden skal lage nettsider.
Se \url{http://css-tricks.com/css-sprites/} hvis du lurer på hvordan det brukes i nettsider.

\end{document}
