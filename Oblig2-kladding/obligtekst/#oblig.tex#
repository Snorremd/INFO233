% PREAMBLE

\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage[T1]{fontenc}

% DOCUMENT
\begin{document}
Obligatorisk oppgave info233, kladd.

\section{Frister, etc.}
\label{sec:frister-og-regler}
Utlevert [dato], frist [data] klokken [klokkeslett]
Etc. Antar det er samme format som forrige gang, med godkjent, ikke godkjent?
Godtar vi parprogrammering?

Leveringsformatet er et Eclipseprosjekt, eksportert til en komprimert fil. (En av: zip, tgz eller tar.gz. Rar-filer godtas ikke.) % Vi kan per lov ikke kommunisere i proprietære formater som rar.


\section{Oppgaven}
\label{sec:oppgaven}
Den andre obligen omhandler en utvidelse av et spill, kalt Kjips Kylling, som er en forenklet klon av Chip's Challenge\footnote{Se \url{http://en.wikipedia.org/wiki/Chip\%27s_Challenge} for mer om spillet}.
Spillet har allerede en enkel grafikkmotor, og dere skal utvide spillet.
Lyd er ikke en del av obligen, og dere kan ignorere alt som har med lyd å gjøre. % Skal vi nevne dette til å begynne med, eller vente til de spør på gruppene?

Før dere begynner å kode anbefaler vi å lese godt igjennom oppgaven, se hvordan relevante kodebiter fungerer, og tenke gjennom før en begynner å kode.
Husk å bruke tiden godt. Det er nok å gjøre, og mye blir lettere å gjøre hvis dere har en plan først. % Jeg kan ikke si dette mange nok ganger, men jeg tror jeg gjør et forsøk her. ^_^;

\section{Spillet}
\label{sec:spillet}
Spillet Kjips Kylling består av flere brett, en spiller og monstre.
Målet med spillet er å klare alle brettene.
For å klare et brett må du komme deg fra begynnelsen på brettet til slutten.
Dersom du går tom for tid, tar ani et monster, eller tråkker på en dødelig rute i spillet dør du.
Når du dør kan du prøve brettet på nytt.
Brettet består av forskjellige ruter. Noen kan gås på, andre ikke. Noen er dødelige, andre ikke.
Brettet har også forskjellige monstre. Disse monstrene beveger seg etter faste mønstre. Monstrene kan ikke dø i denne utgaven.\footnote{I originalen kunne du drepe et monster ved å lure det til å tråkke på en bombe.}
Når du har nådd slutten på et brett begynner neste brett.

\section{Om koden}
\label{sec:om-koden}
\subsection{Introduksjon til kodebasen}
\label{subsec:kodebase-intro}
Koden er lagt opp etter MVC-mønsteret. Det betyr at koden er en av tre ting.
\begin{itemize}
\item Den kan representere en bit av en modell\footnote{I spillet ligger disse klassene under game.entity, og dens underpakker}, dvs. forskjellige ting i programmet, som monstre, spilleren og slikt.
\item Eller så kan den være en bit av en kontroller\footnote{Dette ligger i game.controller}, dvs. noe som styrer oppførsel i programmet
\item Til slutt kan den også være en del av presentasjonen\footnote{Og dette ligger i game.view} av programmet.
\end{itemize}
I tillegg er det IO-pakker som leser fra disk, snakker med andre programmer, etc.

Koden som dere får er sortert under forskjellige pakker, som følger:
\begin{description}
\item [game.controller] Inneholder klassen \emph{Game}, som er en kontroller for spillet.
  Her finner du blant annet en game-loop, som kjører kontinuerlig og som er ansvarlig for å gi ut \emph{ticks}.
\item [game.controller.input] Er hvor input til spillet, som tastatur, mus, gamepads, osv. ligger. Koden dere får har kun en enkel tastaturklasse som tar hånd om input. Dere trenger ikke røre noe kode her inne.
\item [game.entity] Har SimplePlayer som representerer en spiller, og TileLevel som representerer et brett. Andre klasser har egne pakker for å holde ting relativt oversiktlig.
\item [game.entity.monster] Inneholder forskjellige monstre. Når dere får den inneholder den AbstractMonster som er et forenklet monster som ikke har tick() metoden sin implementert, og ExampleMonster som er et monster med alt implementert, slik at dere ser hvordan en kan gjøre det.
\item [game.entity.tiles] Forskjellige klasser som representerer fliser, dvs. en del av brettet, samt hjelpeklasser for å gjøre ting enklere.
\item [game.entity.types] De forskjellige typene entiteter. Her er kun kontrakter, og ikke noen implementerende klasser.
\item [game.io] Har klasser som snakker med disk og evt. andre programmer som en SQL-database.
\item [game.util] Har forskjellige hjelpemetoder, som Direction for retninger, og Movement for hjelpemetoder til bevegelser.
\item [game.view] Har GameWindow-klassen som er en JFrame som holder på et lerret.
  I tillegg til metoder for popups, kan du også legge til kode om du vil ha mer GUI.
\item [game.view.gfx] Hvor grafikken blir tegnet. Det er også en klasse for å laste bildefiler inn til grafikkmotoren. Dere trenger ikke endre noe her. % Den ene klassen som kan være relevant å se nærmere på er SpriteLoader som er ansvarlig for å laste bildefiler til grafikksystemet.
\item [game.main] Inneholder utelukkende Main, en classe som er inngangspunktet\footnote{entry-point} for programmet. Det er bare denne klassen i koden dere får som har en main-metode.
\end{description}

TODO: Få dette renskrevet og inn ordentlig: \\
En kan også dele koden opp i kode dere skal modifisere, og resten.\\
Skal røre: game.view.GameWindow, game.controller.Game, game.entity.TileLevel \\
Skal lage: game.io.ResourceLoaderSQL, game.entity.monster.{OppNed TilVenstre TilHøyre, VenstreHøyre, Målsøkende, Patrulje}Monster
    
\section{Oppgaven}
% -- Hvor de skal sette inn kode % Er vel dekket i forrige?
Oppgaven dere skal gjøre kan deles inn i to hoveddeler: Databasebruk og Monstre. I tillegg er det noen underting som også skal legges til etterpå.
\subsection{Utvidelse til bruk av SQL}
\label{subsec:sqloppgave}
TODO: Renskriving: \\
ResourceLoaderSQL skal lages. \\
HighScore tabell skal lagres, og når du kommer i mål skal den skrives ut, med spilleren sin plassering vist. \\

\subsection{Monstre}
\label{subsec:monsteroppgave}
Dere skal lage monstre som går snur seg når de treffer veggen, som er målsøkende og følger en patruljerute.

\subsection{Til slutt}
\label{subsec:ekstra}
Alle brett skal ha en makstid, utvid brett med en maksimal tid de må fullføre et brett på. Hvis en spiller ikke er i mål når tiden går ut har han tapt.
Når du har klart et brett, skal som er brukt lagres. En skal også vise en liste over de 10 høyeste poengsummene. Dersom spillerens tid e

-- Introduksjon til oppgaven
-- ResourceLoaderSQL (sql/maps!)
-- Highscores! (SQL)
-- Monstre (Kø! (Prioritetskø?))
SELECT score, name from HighScoreWHERE level = ? ORDER BY DESC LIMIT 10;

\section{terminologi}
\subsection{Game-loop}
\label{subsec:game-loop}
En game-loop er en uendelig løkke, og er tradisjonelt delt inn i to:
\begin{description}
\item [oppdatering] Oppdaterer tilstanden til alle objekter i spillet. Blant annet ting som å sjekke om spilleren har dødd, lese ting fra tastaturet, og la datastyrte entiteter som monstre bevege seg.
\item [tegning] tegner verdenen spilleren skal se etter opppdatering.
\end{description}
I spillet dere skal utvide er løkken forenklet, ved at tastaturinput og tegning er gjort for dere.
Det er altså kun oppdatering som skjer i løkken, tegning skjer i en annen tråd.

\subsection{Tick}
\label{subsec:tick}
Et tick er en sjanse til en skapning til å velge å gjøre en ting.
Dersom du for eksempel får 4 ticks i sekundet kan ikke en AI reagere raskere enn 1/4 sekund.
Bare fordi du får n ticks betyr ikke at en AI må bruke alle. Den kan utmerket godt kun bevege seg annenhver tick, eller sjeldnere.
I vårt spill har alle klasser som implementerer Tickable-kontrakten en tick() metode som er void, og lar objekter av den klassen oppdatere seg selv når metoden blir kalt.

\subsection{Sprit}e
\label{subsec:sprite}
En sprite er et mulig bilde av en entitet eller en del av en entitet i et spill.\footnote{I eldre spill som på den første Nintendoen, var det sterkte begrensede ressurser. En tok derfor å tegnet monstre og delte bilde opp i mindre deler, siden prosessoren på Nintendoen ikke kunne tegne hele bilde på en gang. En har siden utvidet teknikken slik at deler av en karakter som er logisk adskilte kan tegnes sammen, slik at du kan skyte av en arm fra et monster, etc. Vi bruker bare et bilde på en entitet.}
For eksempel har monstrene i eksempelmonster fire sprites, og kan dermed se ut på fire forskjellige måter.
En kan selvsagt gjøre ting mer komplisert (tenk på for eksempel animasjoner og slikt), men vi holder oss til enkle ting.

\subsection{Spritesheet}
\label{subsec:spritesheet}
En spritesheet er en bildefil som inneholder mange sprites samlet i en fil. Ble opprinnelig brukt for å spare på systemressurser, og blir fortsatt brukt på internett av den grunn.
(Hvis du har mange bildefiler som må sendes over serveren må du motta og behandle mange kall. Dersom bildefilene er små bruker du plutselig mer tid på å behandle kallene enn på å sende informasjon.
Men dersom du samler alle de små bildene sammen i ett bilde og sender det, og deretter sakser ut biter av bildet til nettsiden din, går alt mye fortere.
Vi som har såpass små bildefiler kunne utmerket godt sluppet unna med å ha separate bildefiler, men vi valgte å ha det med, fordi det er enklere å se hvordan bildene ser ut, mindre File objekter å skyfle rundt på, for å følge tradisjonen, og fordi det er greit å ha sett hvis du i fremtiden skal lage nettsider.
Se \url{http://css-tricks.com/css-sprites/} hvis du lurer på hvordan det brukes i nettsider.

\end{document}
